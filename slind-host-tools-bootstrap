#!/bin/bash
set -x

LIBUTILS=/usr/lib/slind-core/libutils.sh
LIBRARY=/usr/lib/slind-core/libpoolcare.sh

# Another die implementation
die() {
	local error_msg="$@"
	echo "E: $error_msg" >&2
	exit 2
}

info() {
	local error_msg="$@"
	echo "I: $error_msg"
}

[ -f "$LIBUTILS" ] || die  "can't load library $LIBUTILS"
. $LIBUTILS

load_slind_config_common
load_slind_config_maintainer_common
load_suites_config

[ -f "$LIBRARY" ] || die "can't load library $LIBRARY"
. $LIBRARY

SCRIPT_NAME=`basename $0`

# These two are internal to the tool, we don't care about them in global
# configuration.
test -z "$BUILDDIR"           && BUILDDIR="/tmp/base_pkg"
test -z "$TOOLCHAIN_BUILDDIR" && TOOLCHAIN_BUILDDIR="/tmp/tpkg"

SRC_LIST=`conf_get_var_strict $SLIND_CONFIG slind-host-tools-bootstrap src_list`
BIN_LIST=`conf_get_var_strict $SLIND_CONFIG slind-host-tools-bootstrap bin_list`

[ -n "$HTTP_PROXY_URL" ] && PROXYENV="http_proxy=$HTTP_PROXY_URL"
[ -n "$FTP_PROXY_URL" ]  && PROXYENV="$PROXYENV ftp_proxy=$FTP_PROXY_URL"
CHROOTENV="env $PROXYENV $CHROOTENV"

# hackaround for the case of non-existing locales
export LC_ALL=C

# SIGINT handler; removes cruft
# if $NO_CLEAN is set in the environment, this function does nothing
cleanup() {
	if [ -z "$NO_CLEAN" -o "$1" = "force" ]; then
		if [ -d $BUILDDIR ]; then
			rm -rf $BUILDDIR
		fi
		if [ -d $TOOLCHAIN_BUILDDIR ]; then
			rm -rf $TOOLCHAIN_BUILDDIR
		fi
	fi
}

build_package() {
	local pkgname="$1"
	
	local version="`override_get_pkg_version $pkgname $SLIND_SUITE`"

	cd $BUILDDIR
	fakeroot $CHROOTENV apt-get source --compile $pkgname=$version
	if [ "$?" != "0" ]; then
		die "Failed to build $pkgname package"
	fi
}

# This code is somewhat ugly, but we need to live here
# with minimal set of tools - these, which come with etch.

fetch_grasp_git() {

cd $BUILDDIR

if [ -d grasp -a grasp/.git ]; then
        cd grasp && $CHROOTENV git pull || die "Unable to pull from repo"
        cd ..
else
        # We assume here that master branch is what we want
        # This way we could handle both ssh:// and http:// repos.
        # If we are going to parse grasp files, then we have to use http-only
        # repo URL.
        $CHROOTENV git clone ${GITBASE_URL}/grasp.git grasp
        [ -d grasp -a grasp/.git ] || die "Something wicked happened during git clone"
fi
}

build_grasp_git() {

	local version="`override_get_pkg_version $pkgname $SLIND_SUITE`"

	cd $BUILDDIR
	cd grasp && [ -f debian/rules ] && {
		fakeroot make -f debian/rules binary || die "E: Unable to build grasp package"
		grasp_version=`head -n 1 debian/changelog|sed -e 's@.*(\(.*\)).*@\1@g'`
		if [ -n "$grasp_version" ]; then
			$ROOT_CMD dpkg -i ../grasp_${grasp_version}_*.deb || \
				die "grasp installation failed"
		else
			die "Bad grasp version"
		fi
	}
	[ "$?" != "0" ] && die "failed to get into grasp repository dir onbootstrap"
}

# 1. get overrides.db
get_overrides_db() {
	info "=== get overrides.db ==="
	
	# Check if it's a local mirror or not
	if [ "${SLIND_MIRROR#http*:}" = "$SLIND_MIRROR" -a "${SLIND_MIRROR#ftp:}" = "$SLIND_MIRROR" ]; then
	        # Since SLIND_MIRROR is used inside our working chroot, and we
		# determined we're using a local directory, override
		# SLIND_MIRROR with a path _inside_ chroot.
	        SLIND_MIRROR="file:///SLIND"
	fi

	$CHROOTENV curl $SLIND_MIRROR/indices/overrides.db -o $OVERRIDES_DB || \
		die "downloading of $SLIND_MIRROR/indices/overrides.db failed"
}

#
#  In this case we have to put overrides.db in home dir of build user.
#
get_overrides_db_init() {
	set +x
	info "=== get overrides.db (init) ==="
#	cp ~/overrides.db $OVERRIDES_DB || die "copying to $OVERRIDES_DB failed"
	set -x
}

dummy_deliver_cmd() {
	local _pkg="$1"
	local _suite="$2"

	mv "$_pkg" "$CHR_REPODIR"
}


# 2. build base host-tools packages and store them to $CHR_REPODIR
build_base_host_tools_packages() {
	echo "=== building base host-tools packages ==="

	local pkgname

	for pkgname in $SRC_LIST; do
		build_package $pkgname
	done
}
refresh_pool() {
		local _g
		for _g in $ARCHES; do
			make_Packages $SLIND_SUITE $_g
		done
		scan_all_dsc
}
build_base_host_tools_packages_init() {
	echo "=== building base host-tools packages (with grasp) ==="

	local pkgname

	for pkgname in $SRC_LIST; do
		grasp getpkg $pkgname || die "Unable to 'grasp getpkg' package $pkgname"
		grasp build $pkgname || die "Unable to 'grasp build' package $pkgname"
	done
	refresh_pool
	$ROOT_CMD $CHROOTENV apt-get update || die "Could not update apt lists"
	build_base_host_tools_packages
}

# 3. install base host-tool packages from $POOLDIR
install_base_host_tools_packages() {
	echo "=== installing base host-tools packages ==="

	local pkgname
	local pkglist

	pkglist=""
	for pkgname in $BIN_LIST; do
		pkglist="$pkglist ${pkgname}_*.deb"
	done
	( cd $BUILDDIR && \
	$ROOT_CMD dpkg -i $pkglist && \
	$ROOT_CMD $CHROOTENV apt-get -f install --yes --force-yes )
}

# 4. build toolchain packages and store them to $POOLDIR
build_toolchain() {
	echo "=== build toolchains ==="

	local ARCH=$1

	if [ -d $TOOLCHAIN_BUILDDIR -a -z "$NO_CLEAN" ]; then
		rm -rf $TOOLCHAIN_BUILDDIR
	fi

	BINARY_REPO=$CHR_REPODIR SRC_DIR=$TOOLCHAIN_BUILDDIR mktpkg $ARCH
}

# 5. deliver built packages to repository
# $1 -- directory containing *.deb files
deliver_packages() {
	local from="$1"
	local p

	for p in $from/*.deb; do
		$DELIVERCMD $p $SLIND_SUITE
	done
}

case "$1" in
	--initialize-pool)
		# Our repository is initially empty, so lets generate indexes:
		# We don't want this to be run as root
		[ "$UID" -eq "0" ] && die "Never run --initialize-pool as root"
		refresh_pool
		;;
	--build|--build-init)
		[ "$UID" -eq "0" ] && die "Never run --build or --build-init as root"
		# Set up ^C handler
		trap cleanup INT

		cleanup "force"
		mkdir -p $BUILDDIR
		mkdir -p $IDXDIR
		mkdir -p $POOLDIR

		info "=== start toolchain building ==="

		case $1 in
			--build)
				$ROOT_CMD $CHROOTENV apt-get update
				get_overrides_db
				build_base_host_tools_packages
			;;
			--build-init)
				get_overrides_db
				fetch_grasp_git
				build_grasp_git
				build_base_host_tools_packages_init
			;;
		esac
		install_base_host_tools_packages
		deliver_packages $BUILDDIR

		if [ -z "$2" ]; then
			echo "Exiting, no arches were specified."
		else
			shift
			for arch in $@; do
				build_toolchain $arch
				deliver_packages $BUILDDIR
			done
		fi
		
		cleanup
		echo "Done: check the chroot dir $POOLDIR for ready packages."
		exit
		;;

	*)
		echo "Usage: $SCRIPT_NAME { --initialize-pool | { --build | --build-init } [ARCHES] }"
		exit 1
		;;
esac
